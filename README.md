"Базы данных, их типы" 
Ялов Леонид Валерьевич

Задание 1. СУБД
Кейс
Крупная строительная компания, которая также занимается проектированием и девелопментом, решила создать правильную архитектуру для работы с данными. Ниже представлены задачи, которые необходимо решить для каждой предметной области.

Какие типы СУБД, на ваш взгляд, лучше всего подойдут для решения этих задач и почему?

1.1. Бюджетирование проектов с дальнейшим формированием финансовых аналитических отчётов и прогнозирования рисков. СУБД должна гарантировать целостность и чёткую структуру данных.

1.1.* Хеширование стало занимать длительно время, какое API можно использовать для ускорения работы?

1.2. Под каждый девелоперский проект создаётся отдельный лендинг, и все данные по лидам стекаются в CRM к маркетологам и менеджерам по продажам. Какой тип СУБД лучше использовать для лендингов и для CRM? СУБД должны быть гибкими и быстрыми.

1.2.* Можно ли эту задачу закрыть одной СУБД? И если да, то какой именно СУБД и какой реализацией?

1.3. Отдел контроля качества решил создать базу по корпоративным нормам и правилам, обучающему материалу и так далее, сформированную согласно структуре компании. СУБД должна иметь простую и понятную структуру.

1.3.* Можно ли под эту задачу использовать уже существующую СУБД из задач выше и если да, то как лучше это реализовать?

1.4. Департамент логистики нуждается в решении задач по быстрому формированию маршрутов доставки материалов по объектам и распределению курьеров по маршрутам с доставкой документов. СУБД должна уметь быстро работать со связями.

1.4.* Можно ли к этой СУБД подключить отдел закупок или для них лучше сформировать свою СУБД в связке с СУБД логистов?

1.5.* Можно ли все перечисленные выше задачи решить, используя одну СУБД? Если да, то какую именно?

Приведите ответ в свободной форме.


ОТвет 1.1

Нужно вести бюджеты по проектам, потом на основе этого строить аналитику, отчёты и даже прогнозировать риски. И самое главное — данные должны быть чёткими, структурированными и надёжными.
Поэтому, на мой взгляд, тут идеально подойдёт реляционная СУБД — типа PostgreSQL или Microsoft SQL Server.
Во первых, у них строгая структура: всё по таблицам, полям, связям — никакого хаоса.
Во вторых, они гарантируют целостность данных (ACID и всё такое) — если я ввел сумму по статье расходов, она не пропадёт и не исказится.
В третьих, с ними легко делать сложные запросы: например, покажи все проекты, где перерасход по бюджету больше 10% — и сразу видно, где горит. (узнал работая с бухгалтерией :)
Ну и плюс такие базы отлично дружат с Power BI и  другими BI-штучками, которые потом строят красивые графики для руководства и это их устраивает. :)
NoSQL тут, честно, не катит — там всё гибко, но как раз слишком гибко для финансов.
Так что да — ставлю на классику: реляционку. Надёжно, понятно и по-взрослому
1.1.*
 Настроить память под хеш-операции
В PostgreSQL, например, можно увеличить параметр work_mem — тогда хеш-таблицы будут полностью в RAM, а не сбрасываться на диск. Это часто даёт огромный прирост скорости. (Есть минусы: Памяти надо много )
 Использовать расширения с аппаратным ускорением
Если нагрузка серьёзная — подключаем PG-Strom (для PostgreSQL). Это расширение использует CUDA API от NVIDIA, чтобы переносить часть вычислений (включая хеширование при агрегациях и JOIN’ах) на видеокарту. GPU может ускорять не только игры, но и финансовые отчёты. (https://www.opennet.ru/opennews/art.shtml?num=41333) 

 Выбрать СУБД с векторизованным исполнением
Если компания готова к гибридной архитектуре, можно часть аналитики перенести в ClickHouse или SingleStore — там хеши и агрегации оптимизированы на уровне процессора через SIMD-инструкции. Но для оперативного бюджетирования всё равно оставляем реляционку.

Ответ1.2
1.2. Лендинги + CRM
Лендинги — много лидов, разная структура  и нужна гибкость , подходит  NoSQL он же  (MongoDB).
CRM — связи, этапы, отчётность ,  нужна надёжность  тогда  реляционка (PostgreSQL/MySQL).

1.2.* Можно ли одной СУБД?
Да! И лучше так и сделать.
Идеальный выбор — PostgreSQL:
Хранит структурированные данные для CRM ,таблицы, связи.
Поддерживает JSONB — можно кидать любые лиды с любых лендингов без жёсткой схемы.
Быстро ищет по JSONB через GIN-индексы.
Один источник данных → никакой синхронизации, всё сразу видно в CRM.

Ответ 1.3
1.3. База знаний для отдела контроля качества
Нужна простая и понятная структура: нормы, правила, обучающие материалы — всё по иерархии компании (департамент → отдел → должность и т.д.).

Тут отлично подойдёт реляционная СУБД, например PostgreSQL — потому что:
Данные статичные и структурированные (не «а вдруг завтра добавим поле»),
Нужны чёткие связи: «этот документ относится к этому отделу»,
Простота = предсказуемость, а не «всё в куче».
Можно даже обойтись парой таблиц:
documents(id, title, content, type) + document_access(doc_id, dept_id, role).

1.3.* Использовать ли уже выбранную СУБД из задач выше?
Да.
В задаче 1.2 мы уже выбрали PostgreSQL как основную СУБД — и она идеально подходит и для этой задачи.

Как реализовать:
Создать отдельную схему (например, quality_control) в том же кластере PostgreSQL.
Использовать простые таблицы + права доступа (RBAC), чтобы сотрудники видели только своё.
При желании — добавить полнотекстовый поиск (tsvector) для быстрого поиска по правилам.
Плюсы:
Не плодим лишние базы,
Единая инфраструктура и резервное копирование,
Легко интегрировать с внутренним порталом или CRM.

Итог:
PostgreSQL — снова в деле. Просто, надёжно и без изобретения велосипеда :)


ОТВЕТ 1.4.

Нужно быстро находить кратчайшие пути, строить графы, учитывать пробки, загрузку и т.д.
Идеальный выбор — графовая СУБД, например Neo4j.
В ней связи — это не JOIN’ы, а натуральные "рёбра" между узлами.
Запрос вроде «найди все свободные курьеры рядом с объектом X» выполняется в разы быстрее, чем в реляционке.
Встроенные алгоритмы (Shortest Path, Dijkstra) — прямо «из коробки».

1.4.* Подключать ли отдел закупок к этой СУБД?
Не стоит — лучше держать отдельно, но в связке.
У закупок другие данные: поставщики, контракты, цены, сроки — это транзакционная, структурированная информация, где важна целостность, а не графы.
Им подойдёт PostgreSQL 
Как связать логистику и закупки?
→ Через интеграцию на уровне приложения или ETL-процессы:
    Когда создаётся заказ на материалы  -- данные из PostgreSQL (закупки) передаются в Neo4j (логистика) для построения маршрута.
    Обратная связь: статус доставки  --обновляется в PostgreSQL.
Так мы получаем:
 Быструю маршрутизацию в Neo4j,
 Надёжные закупки в PostgreSQL,
 Единый бизнес-процесс без дублирования.

Итог:

Логистика → Neo4j (графы = скорость),
Закупки → PostgreSQL (структура = надёжность),
Связка — через API или ETL, а не одна база на всё.

ОТВЕТ 1.5
 Можно ли всё запустить на одной СУБД?
Технически — да. Практически — с оговорками.
И если выбирать одну СУБД на всё, то лучший компромисс — PostgreSQL.

Почему именно он?
  (Бюджетирование и финансы) — отлично: ACID, строгая схема, аналитика.
  (Лендинги + CRM) — легко: JSONB для гибких лидов + реляционные таблицы для CRM.
  (База знаний) — просто: статичные документы, права доступа, полнотекстовый поиск.
  (Логистика) — тут сложнее, но можно:
 - Хранить узлы и связи в таблицах (nodes, edges),
 - Использовать расширение pgRouting для построения маршрутов,
 - Не так быстро, как Neo4j, но для средней логистики — сойдёт.

Минусы?
Для очень тяжёлой маршрутизации (тысячи курьеров в реальном времени) графовая СУБД всё равно быстрее.
Но если компания не «Яндекс.Лавка», а строительная фирма с десятками объектов — PostgreSQL справится.
Итог:
Да, можно всё на одной СУБД — и это PostgreSQL.
Он гибкий, мощный, бесплатный и закрывает 95% кейсов «из коробки».
Так что если хочется простоту, единый стек и меньше головной боли — ставим на PostgreSQL 

ОТВЕТ 2.1
2.1. Пополнение баланса вручную — 6 шагов успешной транзакции
Пользователь вводит данные — сумму пополнения и номер телефона.
Система проверяет баланс банковской карты или другого источника оплаты — достаточно ли денег?
Блокируется нужная сумма на карте — чтобы её не потратили дважды.
Создаётся транзакция в базе данных — начинается процесс с меткой «в обработке».
Деньги переводятся:
  С карты списывается сумма,
  На телефонный счёт зачисляется баланс.
Транзакция фиксируется (commit) — статус меняется на «успешно», пользователь получает уведомление.
Если на любом этапе ошибка — всё откатывается (rollback), и деньги возвращаются.

2.1. А если пополнение через автоплатёж?
Тогда почти всё то же самое, но без учатия пользователя в момент оплаты:
Система сама запускает платёж по расписанию (например, когда баланс падает ниже 50 ₽).
Проверяется наличие сохранённого способа оплаты (привязанная карта) и её валидность.
Автоматически блокируется сумма на карте (без ввода CVV или подтверждения — если разрешено банком).
Создаётся фоновая транзакция с пометкой «автоплатёж».
Происходит двойное изменение:
  Списание с карты,
   Пополнение телефонного счёта.
Транзакция завершается, и пользователь получает уведомление после факта (SMS или push).
Если карта не работает — система может повторить попытку позже или прислать предупреждение: «Не удалось пополнить, проверьте карту!»
Главное в обоих случаях — транзакция должна быть атомарной: либо всё прошло, либо ничего. Никаких ,деньги списаны, а баланс не пополнился!

ОТВЕТ 3.1

3.1. Пять плюсов SQL-систем перед NoSQL
 1. Надёжность и целостность данных
      SQL гарантирует ACID (атомарность, согласованность, изолированность, долговечность). Если ты переводишь деньги или считаешь бюджет — это критично. В NoSQL такие гарантии часто ослаблены (BASE вместо ACID).
 2. Чёткая структура (схема)
      Всё заранее продумано: какие поля, какие связи. Это спасает от хаоса, особенно когда проект растёт, а в команде 10 разработчиков.
 3. Мощные JOIN’ы
      Нужно собрать данные из 5 таблиц? В SQL — легко. В большинстве NoSQL это либо невозможно, либо приходится делать вручную на уровне приложения (и это медленно + сложно).
 4. Зрелые инструменты и поддержка
      SQL — это де-факто стандарт. Есть куча BI-систем (Power BI), ORM’ов, аналитических инструментов, которые «из коробки» работают с PostgreSQL, MySQL и т.д.
Удобство для аналитики и отчётности
Сложные агрегации, оконные функции, CTE — всё это встроено. В NoSQL часто приходится выгружать данные в отдельное хранилище (data warehouse), чтобы просто посчитать средний чек.
3.1. 

 На мой взгляд - NewSQL — это как ,лучшее из двух миров.

Преимущества перед классическим SQL:

Масштабируется горизонтально (как NoSQL), а не только вертикально.
Выдерживает высокую нагрузку (тысячи транзакций в секунду), что важно для финтеха или e-commerce.
Преимущества перед NoSQL:
Сохраняет ACID-гарантии и поддерживает привычный SQL-синтаксис.
Не нужно жертвовать целостностью ради скорости.
Примеры: CockroachD 
Они идеальны, когда  нужна и надёжность SQL, и масштабируемость NoSQL — например, для сервиса с миллионами пользователей.
Итог:
SQL — для структуры, надёжности и аналитики.
NoSQL — для гибкости и скорости записи в простых сценариях.
NewSQL — когда хочешь всё и сразу (и готов немного переплатить за сложность).